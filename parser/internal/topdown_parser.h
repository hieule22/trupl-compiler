// A top-down, recursive-descent parser for TruPL syntax analysis.
// Copyright 2016 Hieu Le.

#ifndef TRUPLC_PARSER_INTERNAL_TOPDOWN_PARSER_H__
#define TRUPLC_PARSER_INTERNAL_TOPDOWN_PARSER_H__

#include <memory>
#include <string>

#include "parser/symbol_table.h"
#include "scanner/scanner.h"
#include "tokens/token.h"

namespace truplc {
namespace internal {

class TopdownParser {
 public:
  // Constructs a TopdownParser for a specified Scanner.
  // Ownership of the Scanner is acquired by this TopdownParser instance.
  explicit TopdownParser(std::unique_ptr<Scanner> scanner);

  // Parse the program generated by tokens from Scanner.
  bool ParseProgram();

  // Checks if all the tokens by Scanner have been consumed.
  bool HasNextToken() const;

 private:
  // The Scanner associated with this TopdownParser.
  std::unique_ptr<Scanner> scanner_;

  /*********** Syntax Analysis **********/
  // Advance to the next token.
  void Advance();

  // Parser functions for each non-terminal in TruPL.
  bool ParseDeclList();
  bool ParseVariableDeclList();
  bool ParseVariableDecl();
  bool ParseProcedureDeclList();
  bool ParseIdentifierList();
  bool ParseIdentifierListPrm();
  bool ParseStandardType(ExpressionType* standard_type_type);
  bool ParseBlock();
  bool ParseProcedureDecl();
  bool ParseProcedureArgs();
  bool ParseFormalParmList();
  bool ParseFormalParmListHat();
  bool ParseStmtList();
  bool ParseStmtListPrm();
  bool ParseStmt();
  bool ParseAdhocAsPcTail(ExpressionType* adhoc_as_pc_tail_type);
  bool ParseIfStmt();
  bool ParseIfStmtHat();
  bool ParseWhileStmt();
  bool ParsePrintStmt();
  bool ParseExprList();
  bool ParseActualParmList();
  bool ParseActualParmListHat();
  bool ParseExpr(ExpressionType* expr_type_result);
  bool ParseExprHat(ExpressionType* expr_hat_type);
  bool ParseSimpleExpr(ExpressionType* simple_expr_type);
  bool ParseSimpleExprPrm(ExpressionType* simple_expr_prm_type);
  bool ParseTerm(ExpressionType* term_type);
  bool ParseTermPrm(ExpressionType* term_prm_type);
  bool ParseFactor(ExpressionType* factor_type);
  bool ParseSign(ExpressionType* sign_type);

  // Reports syntax errors to console.
  // Message format: "Parse error! Expected: *expected" Actual: *actual*.
  void ReportSyntaxError(const std::string& expected,
                         const Token& actual) const;

  // The token that is being examined.
  std::unique_ptr<Token> word_;

  /*********** Semantial Analysis **********/
  // Reports semantic errors to console. These include declaring a previously
  // defined identifier, manipulating an undeclared identifier and type mismatch
  // errors.
  void ReportMultiplyDefinedIdentifier(const std::string& identifier) const;
  void ReportUndeclaredIdentifier(const std::string& identifier) const;
  void ReportTypeError(ExpressionType expected, ExpressionType actual) const;
  void ReportTypeError(ExpressionType expected0, ExpressionType expected1,
                       ExpressionType actual) const;

  // Name of current environment that is being parsed.
  std::string current_env_;
  // Name of environment of main program.
  std::string main_env_;
  // Name of potential procedure when examining a procedure call.
  std::string procedure_name_;
  // Position of an actual parameter in a procedure call.
  int actual_parm_position_;
  // Position of a formal parameter in a procedure call.
  int formal_parm_position_;
  // A Boolean value that is true only when parsing a formal parameter list.
  bool parsing_formal_parm_list_;

  // The symbol table.
  SymbolTable symtable_;
};

}  // namespace internal
}  // namespace truplc

#endif  // TRUPLC_PARSER_INTERNAL_TOPDOWN_PARSER_H__
